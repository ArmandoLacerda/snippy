# This is an Azure Functions application that demonstrates several key Azure services:
# 1. Azure Functions with HTTP and MCP triggers
# 2. Azure Cosmos DB for document storage
# 3. Azure OpenAI for generating embeddings
# 4. Azure AI Agents for code analysis
# 5. Vector search capabilities using embeddings

import json
import logging
import azure.functions as func
from data import cosmos_ops  # Module for Cosmos DB operations
from agents import deep_wiki, code_style  # Modules for AI agent operations

# Create the Azure Functions app instance
# This is the entry point for all function definitions
app = func.FunctionApp()

# Constants for MCP (Microsoft Copilot) tool properties
# These define the schema for the MCP tool inputs
_SNIPPET_NAME_PROPERTY_NAME = "snippetname"
_SNIPPET_PROPERTY_NAME = "snippet"
_PROJECT_ID_PROPERTY_NAME = "projectid"
_CHAT_HISTORY_PROPERTY_NAME = "chathistory"
_USER_QUERY_PROPERTY_NAME = "userquery"

# Class to define properties for MCP tools
# This helps validate and document the expected inputs for each tool
class ToolProperty:
    def __init__(self, property_name: str, property_type: str, description: str):
        self.propertyName = property_name
        self.propertyType = property_type
        self.description = description

    def to_dict(self):
        return {
            "propertyName": self.propertyName,
            "propertyType": self.propertyType,
            "description": self.description,
        }

# Define the tool properties for each MCP tool
# These properties define what inputs each tool expects
tool_properties_save_snippets = [
    ToolProperty(_SNIPPET_NAME_PROPERTY_NAME, "string", "The name of the snippet."),
    ToolProperty(_PROJECT_ID_PROPERTY_NAME, "string", "The ID of the project. Optional, defaults to 'default-project' if not provided."),
    ToolProperty(_SNIPPET_PROPERTY_NAME, "string", "The content of the snippet."),
]

tool_properties_get_snippets = [
    ToolProperty(_SNIPPET_NAME_PROPERTY_NAME, "string", "The name of the snippet."),
]

tool_properties_wiki = [
    ToolProperty(_CHAT_HISTORY_PROPERTY_NAME, "string", "The chat history or chat session for context."),
    ToolProperty(_USER_QUERY_PROPERTY_NAME, "string", "The user's query for wiki generation."),
]

tool_properties_code_style = [
    ToolProperty(_CHAT_HISTORY_PROPERTY_NAME, "string", "The chat history or chat session for context."),
    ToolProperty(_USER_QUERY_PROPERTY_NAME, "string", "The user's query for code style analysis."),
]

# Convert tool properties to JSON for MCP tool registration
# This is required by the MCP tool trigger binding
tool_properties_save_snippets_json = json.dumps([prop.to_dict() for prop in tool_properties_save_snippets])
tool_properties_get_snippets_json = json.dumps([prop.to_dict() for prop in tool_properties_get_snippets])
tool_properties_wiki_json = json.dumps([prop.to_dict() for prop in tool_properties_wiki])
tool_properties_code_style_json = json.dumps([prop.to_dict() for prop in tool_properties_code_style])

# HTTP trigger for saving snippets
# This demonstrates a standard HTTP trigger with Azure OpenAI embeddings input
@app.route(route="snippets", methods=["POST"], auth_level=func.AuthLevel.FUNCTION)
@app.embeddings_input(arg_name="embeddings", input="{code}", input_type="rawText", model="%EMBEDDING_MODEL_DEPLOYMENT_NAME%")
async def http_save_snippet(req: func.HttpRequest, embeddings: str) -> func.HttpResponse:
    """
    HTTP trigger function to save a code snippet.
    This function demonstrates:
    1. HTTP trigger binding
    2. Azure OpenAI embeddings generation
    3. Cosmos DB document storage
    4. Error handling and validation
    
    Args:
        req: The HTTP request containing the snippet data
        embeddings: The embeddings generated by Azure OpenAI
        
    Returns:
        HTTP response with the saved snippet data
    """
    try:
        # Parse the request body
        req_body = req.get_json()
        
        # Validate required fields
        required_fields = ["name", "code"]
        for field in required_fields:
            if field not in req_body:
                return func.HttpResponse(
                    body=json.dumps({"error": f"Missing required field: {field}"}),
                    mimetype="application/json",
                    status_code=400
                )
        
        # Set default projectId if not provided
        if "projectId" not in req_body:
            req_body["projectId"] = "default-project"
        
        # Log input text and embeddings data for debugging
        logging.info(f"Input text length: {len(req_body['code'])} characters")
        logging.info(f"Input text preview: {req_body['code'][:100]}...")
        
        try:
            # Parse embeddings from the input binding
            # The embeddings are generated by Azure OpenAI and passed through the binding
            embeddings_data = json.loads(embeddings)
            logging.info(f"Embeddings data keys: {list(embeddings_data.keys())}")
            
            if "response" not in embeddings_data:
                raise ValueError("Embeddings data missing 'response' key")
                
            response_data = embeddings_data["response"]
            if "data" not in response_data:
                raise ValueError("Embeddings response missing 'data' key")
                
            # Extract the embedding vector from the response
            # This vector will be used for vector search in Cosmos DB
            embedding_vector = response_data["data"][0]["embedding"]
            logging.info(f"Embedding vector length: {len(embedding_vector)}")
            logging.info(f"First 5 embedding values: {embedding_vector[:5]}")
            
            # Save snippet to Cosmos DB with embeddings
            # This demonstrates vector search capabilities in Cosmos DB
            result = await cosmos_ops.upsert_document(
                name=req_body["name"],
                project_id=req_body["projectId"],
                code=req_body["code"],
                embedding=embedding_vector
            )
        except json.JSONDecodeError as e:
            logging.error(f"Failed to parse embeddings JSON: {str(e)}")
            return func.HttpResponse(
                body=json.dumps({"error": "Invalid embeddings data format"}),
                mimetype="application/json",
                status_code=500
            )
        except (KeyError, IndexError) as e:
            logging.error(f"Embeddings data structure error: {str(e)}")
            return func.HttpResponse(
                body=json.dumps({"error": "Invalid embeddings data structure"}),
                mimetype="application/json",
                status_code=500
            )
        
        return func.HttpResponse(
            body=json.dumps(result),
            mimetype="application/json",
            status_code=200
        )
    except Exception as e:
        logging.error(f"Error in http_save_snippet: {str(e)}")
        return func.HttpResponse(
            body=json.dumps({"error": str(e)}),
            mimetype="application/json",
            status_code=500
        )

# MCP tool trigger for saving snippets
# This demonstrates the MCP tool trigger binding
@app.generic_trigger(
    arg_name="context",
    type="mcpToolTrigger",
    toolName="save_snippet",
    description="Save a code snippet with name and project ID.",
    toolProperties=tool_properties_save_snippets_json,
)
@app.embeddings_input(arg_name="embeddings", input="{arguments.snippet}", input_type="rawText", model="%EMBEDDING_MODEL_DEPLOYMENT_NAME%")
async def mcp_save_snippet(context: str, embeddings: str) -> str:
    """
    MCP tool trigger function to save a code snippet.
    This function demonstrates:
    1. MCP tool trigger binding
    2. Azure OpenAI embeddings generation
    3. Cosmos DB document storage
    4. Error handling and validation
    
    Args:
        context: The MCP tool context containing the snippet data
        embeddings: The embeddings generated by Azure OpenAI
        
    Returns:
        JSON string with the saved snippet data
    """
    try:
        # Parse the incoming context string
        # MCP tools pass data through a context object
        mcp_data = json.loads(context)
        
        # Extract required fields from the MCP context
        name = mcp_data["arguments"][_SNIPPET_NAME_PROPERTY_NAME]
        project_id = mcp_data["arguments"].get(_PROJECT_ID_PROPERTY_NAME, "default-project")
        code = mcp_data["arguments"][_SNIPPET_PROPERTY_NAME]
        
        # Log input text and embeddings data for debugging
        logging.info(f"Input text length: {len(code)} characters")
        logging.info(f"Input text preview: {code[:100]}...")
        
        try:
            # Parse embeddings from the input binding
            # The embeddings are generated by Azure OpenAI and passed through the binding
            embeddings_data = json.loads(embeddings)
            logging.info(f"Embeddings data keys: {list(embeddings_data.keys())}")
            
            if "response" not in embeddings_data:
                raise ValueError("Embeddings data missing 'response' key")
                
            response_data = embeddings_data["response"]
            if "data" not in response_data:
                raise ValueError("Embeddings response missing 'data' key")
                
            # Extract the embedding vector from the response
            # This vector will be used for vector search in Cosmos DB
            embedding_vector = response_data["data"][0]["embedding"]
            logging.info(f"Embedding vector length: {len(embedding_vector)}")
            logging.info(f"First 5 embedding values: {embedding_vector[:5]}")
            
            # Save snippet to Cosmos DB with embeddings
            # This demonstrates vector search capabilities in Cosmos DB
            result = await cosmos_ops.upsert_document(
                name=name,
                project_id=project_id,
                code=code,
                embedding=embedding_vector
            )
        except json.JSONDecodeError as e:
            logging.error(f"Failed to parse embeddings JSON: {str(e)}")
            return json.dumps({"error": "Invalid embeddings data format"})
        except (KeyError, IndexError) as e:
            logging.error(f"Embeddings data structure error: {str(e)}")
            return json.dumps({"error": "Invalid embeddings data structure"})
        
        return json.dumps(result)
    except json.JSONDecodeError:
        logging.error(f"Failed to decode JSON from MCP context: {context}")
        return json.dumps({"error": "Invalid JSON received in context"})
    except KeyError as e:
        logging.error(f"Missing key in parsed MCP context: {e}")
        return json.dumps({"error": f"Missing expected argument: {e}"})
    except Exception as e:
        logging.error(f"Error in mcp_save_snippet: {str(e)}")
        return json.dumps({"error": str(e)})

# HTTP trigger for getting snippets
# This demonstrates a standard HTTP trigger with route parameters
@app.route(route="snippets/{name}", methods=["GET"], auth_level=func.AuthLevel.FUNCTION)
async def http_get_snippet(req: func.HttpRequest) -> func.HttpResponse:
    """
    HTTP trigger function to get a code snippet by name.
    This function demonstrates:
    1. HTTP trigger with route parameters
    2. Cosmos DB document retrieval
    3. Error handling and validation
    
    Args:
        req: The HTTP request containing the snippet name in the route
        
    Returns:
        HTTP response with the snippet data
    """
    try:
        # Extract the snippet name from the route parameters
        name = req.route_params.get("name")
        if not name:
            return func.HttpResponse(
                body=json.dumps({"error": "Missing snippet name in route"}),
                mimetype="application/json",
                status_code=400
            )
        
        # Get snippet from Cosmos DB
        # This demonstrates document retrieval from Cosmos DB
        snippet = await cosmos_ops.get_snippet_by_id(name)
        if not snippet:
            return func.HttpResponse(
                body=json.dumps({"error": f"Snippet '{name}' not found"}),
                mimetype="application/json",
                status_code=404
            )
        
        return func.HttpResponse(
            body=json.dumps(snippet),
            mimetype="application/json",
            status_code=200
        )
    except Exception as e:
        logging.error(f"Error in http_get_snippet: {str(e)}")
        return func.HttpResponse(
            body=json.dumps({"error": str(e)}),
            mimetype="application/json",
            status_code=500
        )

# MCP tool trigger for getting snippets
# This demonstrates the MCP tool trigger binding
@app.generic_trigger(
    arg_name="context",
    type="mcpToolTrigger",
    toolName="get_snippet",
    description="Get a code snippet by name.",
    toolProperties=tool_properties_get_snippets_json,
)
async def mcp_get_snippet(context) -> str:
    """
    MCP tool trigger function to get a code snippet by name.
    This function demonstrates:
    1. MCP tool trigger binding
    2. Cosmos DB document retrieval
    3. Error handling and validation
    
    Args:
        context: The MCP tool context containing the snippet name
        
    Returns:
        JSON string with the snippet data
    """
    try:
        # Parse the incoming context string
        # MCP tools pass data through a context object
        mcp_data = json.loads(context)
        
        # Extract the snippet name from the MCP context
        name = mcp_data["arguments"][_SNIPPET_NAME_PROPERTY_NAME]
        if not name:
            return json.dumps({"error": "Missing snippet name in MCP context"})
        
        # Get snippet from Cosmos DB
        # This demonstrates document retrieval from Cosmos DB
        snippet = await cosmos_ops.get_snippet_by_id(name)
        if not snippet:
            return json.dumps({"error": f"Snippet '{name}' not found"})
        
        return json.dumps(snippet)
    except json.JSONDecodeError:
        logging.error(f"Failed to decode JSON from MCP context: {context}")
        return json.dumps({"error": "Invalid JSON received in context"})
    except KeyError as e:
        logging.error(f"Missing key in parsed MCP context: {e}")
        return json.dumps({"error": f"Missing expected argument: {e}"})
    except Exception as e:
        logging.error(f"Error in mcp_get_snippet: {str(e)}")
        return json.dumps({"error": str(e)})

# HTTP trigger for code style
# This demonstrates integration with Azure AI Agents
@app.route(route="snippets/code-style", methods=["POST"], auth_level=func.AuthLevel.FUNCTION)
async def http_code_style(req: func.HttpRequest) -> func.HttpResponse:
    """
    HTTP trigger function to generate a code style guide using an AI agent.
    This function demonstrates:
    1. HTTP trigger
    2. Azure AI Agents integration
    3. Error handling and logging
    
    Args:
        req: The HTTP request containing chat history and user query
        
    Returns:
        HTTP response with the code style guide
    """
    try:
        logging.info("Starting code style generation using AI agent")
        
        # Parse the request body
        req_body = req.get_json()
        
        # Validate required fields
        required_fields = ["chatHistory", "userQuery"]
        for field in required_fields:
            if field not in req_body:
                return func.HttpResponse(
                    body=json.dumps({"error": f"Missing required field: {field}"}),
                    mimetype="application/json",
                    status_code=400
                )
        
        # Generate code style guide using AI agent
        style_guide = await code_style.generate_code_style(
            chat_history=req_body["chatHistory"],
            user_query=req_body["userQuery"]
        )
        logging.info("Successfully generated code style guide")
        
        return func.HttpResponse(
            body=json.dumps({"styleGuide": style_guide}),
            mimetype="application/json",
            status_code=200
        )
    except Exception as e:
        logging.error(f"Error in http_code_style: {str(e)}", exc_info=True)
        return func.HttpResponse(
            body=json.dumps({"error": str(e)}),
            mimetype="application/json",
            status_code=500
        )

# MCP tool trigger for code style
# This demonstrates integration with Azure AI Agents through MCP
@app.generic_trigger(
    arg_name="context",
    type="mcpToolTrigger",
    toolName="code_style",
    description="Generate a code style guide using an AI agent.",
    toolProperties=tool_properties_code_style_json,
)
async def mcp_code_style(context) -> str:
    """
    MCP tool trigger function to generate a code style guide using an AI agent.
    This function demonstrates:
    1. MCP tool trigger binding
    2. Azure AI Agents integration
    3. Error handling and logging
    
    Args:
        context: The MCP tool context containing chat history and user query
        
    Returns:
        JSON string with the code style guide
    """
    try:
        logging.info("Starting MCP code style generation using AI agent")
        
        # Parse the incoming context string
        mcp_data = json.loads(context)
        
        # Extract required fields from the MCP context
        chat_history = mcp_data["arguments"][_CHAT_HISTORY_PROPERTY_NAME]
        user_query = mcp_data["arguments"][_USER_QUERY_PROPERTY_NAME]
        
        # Generate code style guide using AI agent
        style_guide = await code_style.generate_code_style(
            chat_history=chat_history,
            user_query=user_query
        )
        logging.info("Successfully generated code style guide")
        
        return json.dumps({"styleGuide": style_guide})
    except json.JSONDecodeError:
        logging.error(f"Failed to decode JSON from MCP context: {context}")
        return json.dumps({"error": "Invalid JSON received in context"})
    except KeyError as e:
        logging.error(f"Missing key in parsed MCP context: {e}")
        return json.dumps({"error": f"Missing expected argument: {e}"})
    except Exception as e:
        logging.error(f"Error in mcp_code_style: {str(e)}", exc_info=True)
        return json.dumps({"error": str(e)})

@app.route(route="snippets/wiki", methods=["POST"], auth_level=func.AuthLevel.FUNCTION)
async def http_deep_wiki(req: func.HttpRequest) -> func.HttpResponse:
    """
    HTTP trigger function to generate wiki documentation for all code snippets.
    This function demonstrates:
    1. HTTP trigger binding
    2. Azure AI Agents for documentation generation
    3. Vector search in Cosmos DB
    4. Error handling and validation
    
    Args:
        req: The HTTP request containing chat history and user query
        
    Returns:
        HTTP response with the generated wiki documentation
    """
    try:
        # Parse the request body
        req_body = req.get_json()
        
        # Validate required fields
        required_fields = ["chatHistory", "userQuery"]
        for field in required_fields:
            if field not in req_body:
                return func.HttpResponse(
                    body=json.dumps({"error": f"Missing required field: {field}"}),
                    mimetype="application/json",
                    status_code=400
                )
        
        # Generate wiki documentation
        wiki_content = await deep_wiki.generate_deep_wiki(
            chat_history=req_body["chatHistory"],
            user_query=req_body["userQuery"]
        )
        
        return func.HttpResponse(
            body=wiki_content,
            mimetype="text/markdown",
            status_code=200
        )
    except Exception as e:
        logging.error(f"Error in http_deep_wiki: {str(e)}")
        return func.HttpResponse(
            body=json.dumps({"error": str(e)}),
            mimetype="application/json",
            status_code=500
        )

@app.generic_trigger(
    arg_name="context",
    type="mcpToolTrigger",
    toolName="deep_wiki",
    description="Generates comprehensive wiki documentation (deep wiki) for all code snippets.",
    toolProperties=tool_properties_wiki_json,
)
async def mcp_deep_wiki(context) -> str:
    """
    MCP tool trigger function to generate wiki documentation (deep wiki) for all code snippets.
    This function demonstrates:
    1. MCP tool trigger binding
    2. Azure AI Agents for documentation generation
    3. Vector search in Cosmos DB
    4. Error handling and validation
    
    Args:
        context: The MCP tool context containing chat history and user query
        
    Returns:
        JSON string with the generated wiki documentation
    """
    try:
        # Parse the incoming context string
        mcp_data = json.loads(context)
        
        # Extract required fields from the MCP context
        chat_history = mcp_data["arguments"][_CHAT_HISTORY_PROPERTY_NAME]
        user_query = mcp_data["arguments"][_USER_QUERY_PROPERTY_NAME]
        
        # Generate wiki documentation
        wiki_content = await deep_wiki.generate_deep_wiki(
            chat_history=chat_history,
            user_query=user_query
        )
        
        return wiki_content
    except json.JSONDecodeError:
        logging.error(f"Failed to decode JSON from MCP context: {context}")
        return json.dumps({"error": "Invalid JSON received in context"})
    except KeyError as e:
        logging.error(f"Missing key in parsed MCP context: {e}")
        return json.dumps({"error": f"Missing expected argument: {e}"})
    except Exception as e:
        logging.error(f"Error in mcp_deep_wiki: {str(e)}")
        return json.dumps({"error": str(e)})

